scad_mse <- summary_table$MSE[summary_table$Method == "SCAD (LLA)"]
lasso_mse <- summary_table$MSE[summary_table$Method == "LASSO"]
scad_improved_r2 <- summary_table$OOS_R2[summary_table$Method == "SCAD (LLA_Updated)"]
scad_r2 <- summary_table$OOS_R2[summary_table$Method == "SCAD (LLA)"]
lasso_r2 <- summary_table$OOS_R2[summary_table$Method == "LASSO"]
best_mse_idx <- which.min(summary_table$MSE)
best_r2_idx <- which.max(summary_table$OOS_R2)
cat("\nBest Performance:\n")
cat(sprintf("  Lowest MSE: %s (%.6f)\n", summary_table$Method[best_mse_idx], summary_table$MSE[best_mse_idx]))
cat(sprintf("  Highest R²: %s (%.4f)\n", summary_table$Method[best_r2_idx], summary_table$OOS_R2[best_r2_idx]))
if (scad_improved_mse < lasso_mse && scad_improved_r2 > lasso_r2) {
cat("\n✅ SCAD (LLA_Updated) outperforms LASSO!\n")
cat(sprintf("   SCAD (LLA_Updated) MSE: %.6f < LASSO MSE: %.6f\n", scad_improved_mse, lasso_mse))
cat(sprintf("   SCAD (LLA_Updated) R²: %.4f > LASSO R²: %.4f\n", scad_improved_r2, lasso_r2))
}
if (scad_improved_mse < scad_mse && scad_improved_r2 > scad_r2) {
cat("\n✅ SCAD (LLA_Updated) outperforms SCAD (LLA)!\n")
cat(sprintf("   LLA_Updated provides better numerical stability\n"))
}
} else if (nrow(summary_table) == 2) {
scad_mse <- summary_table$MSE[summary_table$Method == "SCAD (LLA)"]
lasso_mse <- summary_table$MSE[summary_table$Method == "LASSO"]
scad_r2 <- summary_table$OOS_R2[summary_table$Method == "SCAD (LLA)"]
lasso_r2 <- summary_table$OOS_R2[summary_table$Method == "LASSO"]
if (scad_mse < lasso_mse && scad_r2 > lasso_r2) {
cat("\n✅ SCAD (LLA) outperforms LASSO!\n")
}
}
}
return(summary_table)
}
construct_portfolio <- function(data_list, results, ff_factors, top_pct = 0.3) {
cat("\n===========================================\n")
cat("Portfolio Construction: Beta-Weighted & Mean-Variance\n")
cat("All methods use both portfolio construction approaches\n")
cat("===========================================\n\n")
flush.console()
if (!inherits(ff_factors$date, "Date")) {
ff_factors$date <- as.Date(ff_factors$date, format = "%Y-%m-%d")
}
factor_cols <- setdiff(colnames(ff_factors), "date")
main_factor <- "Mkt_RF"
portfolio_returns_beta <- list(lasso = numeric(), scad = numeric(), scad_improved = numeric())
portfolio_returns_mv <- list(lasso = numeric(), scad = numeric(), scad_improved = numeric())
all_test_dates <- c()
for (stock in names(results)) {
if (!stock %in% names(data_list)) next
stock_data <- data_list[[stock]]
test_indices <- results[[stock]]$test_indices
if (length(test_indices) > 0) {
test_dates <- stock_data$dates[test_indices]
all_test_dates <- c(all_test_dates, as.character(test_dates))
}
}
all_test_dates <- unique(sort(all_test_dates))
all_test_dates <- all_test_dates[all_test_dates %in% as.character(ff_factors$date)]
cat(sprintf("Constructing portfolios for %d test dates...\n", length(all_test_dates)))
flush.console()
for (test_date_str in all_test_dates) {
test_date <- as.Date(test_date_str, format = "%Y-%m-%d")
# ⭐ Reference: simulation_data.R - use predicted returns from all factors
# Instead of single factor beta, compute predicted returns: r_hat = X * beta
predicted_returns_lasso <- numeric()
predicted_returns_scad <- numeric()
predicted_returns_scad_improved <- numeric()
next_returns <- numeric()
valid_stocks <- character()
X_factors_list <- list()  # Store factor values for each stock
for (stock in names(results)) {
if (!stock %in% names(data_list)) next
stock_result <- results[[stock]]
stock_data <- data_list[[stock]]
test_indices <- stock_result$test_indices
if (length(test_indices) == 0) next
test_dates <- stock_data$dates[test_indices]
date_match <- which(test_dates == test_date)
if (length(date_match) == 0) next
if (date_match >= length(test_indices)) next
# Get factor values at test date (for prediction)
factor_date_idx <- which(ff_factors$date == test_date)
if (length(factor_date_idx) == 0) next
# Get factor values (all factors, not just main_factor)
factor_vals <- as.numeric(ff_factors[factor_date_idx, factor_cols, drop = FALSE])
if (length(factor_vals) != length(stock_result$factor_names)) next
# Compute predicted returns using all factors: r_hat = X * beta
# This is the same as simulation_data.R: r_hat = X_test %*% beta_hat
beta_lasso_all <- stock_result$lasso_loadings
beta_scad_all <- stock_result$scad_loadings
beta_scad_improved_all <- stock_result$scad_improved_loadings
if (length(beta_lasso_all) != length(factor_vals) ||
length(beta_scad_all) != length(factor_vals) ||
length(beta_scad_improved_all) != length(factor_vals)) next
# Predicted returns: r_hat = sum(X_j * beta_j) for all factors j
pred_ret_lasso <- sum(factor_vals * beta_lasso_all)
pred_ret_scad <- sum(factor_vals * beta_scad_all)
pred_ret_scad_improved <- sum(factor_vals * beta_scad_improved_all)
next_return <- stock_data$y[test_indices[date_match + 1]]
if (is.finite(pred_ret_lasso) && is.finite(pred_ret_scad) && is.finite(pred_ret_scad_improved) &&
is.finite(next_return) && abs(next_return) < 0.5) {
predicted_returns_lasso <- c(predicted_returns_lasso, pred_ret_lasso)
predicted_returns_scad <- c(predicted_returns_scad, pred_ret_scad)
predicted_returns_scad_improved <- c(predicted_returns_scad_improved, pred_ret_scad_improved)
next_returns <- c(next_returns, next_return)
valid_stocks <- c(valid_stocks, stock)
X_factors_list[[stock]] <- factor_vals  # Store for covariance calculation
}
}
if (length(predicted_returns_lasso) >= 3) {
# ========================================================================
# Method 1: Beta-weighted Portfolio
# ========================================================================
# ⭐ Reference: simulation_data.R - weights proportional to predicted returns
# Use predicted returns (r_hat) as signals, not single factor beta
# r_hat = X * beta (all factors), weights = r_hat / sum(|r_hat|)
# Calculate with safety checks
sum_abs_lasso <- sum(abs(predicted_returns_lasso))
sum_abs_scad <- sum(abs(predicted_returns_scad))
sum_abs_scad_improved <- sum(abs(predicted_returns_scad_improved))
if (sum_abs_lasso > 1e-8) {
weights_lasso_beta <- predicted_returns_lasso / sum_abs_lasso
port_ret_lasso_beta <- sum(weights_lasso_beta * next_returns)
} else {
port_ret_lasso_beta <- 0
}
if (sum_abs_scad > 1e-8) {
weights_scad_beta <- predicted_returns_scad / sum_abs_scad
port_ret_scad_beta <- sum(weights_scad_beta * next_returns)
} else {
port_ret_scad_beta <- 0
# ⭐ Debug: Check if SCAD predicted returns are all zero
if (length(all_test_dates) <= 5 || test_date_str == all_test_dates[1]) {
cat(sprintf("  ⚠️  Warning: SCAD predicted returns sum to %.6f\n", sum_abs_scad))
cat(sprintf("     SCAD pred returns: min=%.6f, max=%.6f, mean=%.6f\n",
min(predicted_returns_scad), max(predicted_returns_scad), mean(predicted_returns_scad)))
}
}
if (sum_abs_scad_improved > 1e-8) {
weights_scad_improved_beta <- predicted_returns_scad_improved / sum_abs_scad_improved
port_ret_scad_improved_beta <- sum(weights_scad_improved_beta * next_returns)
} else {
port_ret_scad_improved_beta <- 0
if (length(all_test_dates) <= 5 || test_date_str == all_test_dates[1]) {
cat(sprintf("  ⚠️  Warning: SCAD Improved predicted returns sum to %.6f\n", sum_abs_scad_improved))
cat(sprintf("     SCAD Improved pred returns: min=%.6f, max=%.6f, mean=%.6f\n",
min(predicted_returns_scad_improved), max(predicted_returns_scad_improved),
mean(predicted_returns_scad_improved)))
}
}
# ========================================================================
# Method 2: Mean-Variance Portfolio
# ========================================================================
# ⭐ Reference: simulation_data.R implementation
# Mean-variance optimization: w = (Σ^(-1) μ) / (1^T Σ^(-1) μ)
# where μ = betas (expected returns signal), Σ = factor-based covariance matrix
# Covariance structure: Σ = X diag(β²) X^T + Σ_ε (factor model)
port_ret_lasso_mv <- port_ret_lasso_beta  # Default fallback
port_ret_scad_mv <- port_ret_scad_beta
port_ret_scad_improved_mv <- port_ret_scad_improved_beta
if (length(next_returns) >= 3 && length(predicted_returns_lasso) == length(next_returns)) {
n_stocks <- length(next_returns)
# Get baseline variance from actual returns
var_returns <- var(next_returns)
if (!is.finite(var_returns) || var_returns <= 0) {
var_returns <- 0.01  # Default variance
}
# ⭐ Build covariance matrix using factor model structure
# Reference: simulation_data.R - Σ = X diag(β²) X^T + Σ_ε
# In real data: construct X matrix from factor values, use full beta vectors
# Helper function to build covariance matrix for a method
# Uses all factors, not just single factor beta
build_covariance_mv <- function(pred_returns, beta_all, X_factors, var_base, rho_idio = 0.0) {
n <- length(pred_returns)
# ⭐ Factor part: Σ_factor = X diag(β²) X^T (like simulation)
# X is n_stocks × n_factors matrix of factor values
# beta_all is n_factors vector of loadings
if (length(X_factors) == n && length(beta_all) > 0) {
# Build X matrix: each row is factor values for one stock
X_mat <- do.call(rbind, X_factors)
if (nrow(X_mat) == n && ncol(X_mat) == length(beta_all)) {
# Σ_factor = X diag(β²) X^T
beta_sq <- beta_all^2
X_scaled <- sweep(X_mat, 2, beta_sq, "*")
Sigma_factor <- X_scaled %*% t(X_mat)
# Scale to match return variance
factor_scale <- mean(diag(Sigma_factor))
if (factor_scale > 0 && is.finite(factor_scale)) {
Sigma_factor <- Sigma_factor * (var_base * 0.5 / factor_scale)
} else {
Sigma_factor <- outer(pred_returns, pred_returns) * 0.1
}
} else {
# Fallback: use predicted returns
Sigma_factor <- outer(pred_returns, pred_returns) * 0.1
}
} else {
# Fallback: use predicted returns
Sigma_factor <- outer(pred_returns, pred_returns) * 0.1
}
# Idiosyncratic part: Σ_ε
idio_var <- var_base * 0.5  # Remaining 50% is idiosyncratic
if (rho_idio > 0 && n > 1) {
# Add correlation structure to idiosyncratic component
Sigma_eps <- matrix(0, nrow = n, ncol = n)
for (i in 1:n) {
for (j in 1:n) {
Sigma_eps[i, j] <- idio_var * (rho_idio^abs(i - j))
}
}
diag(Sigma_eps) <- idio_var
Sigma <- Sigma_factor + Sigma_eps
} else {
Sigma <- Sigma_factor + diag(n) * idio_var
}
# Ensure positive definite and well-conditioned
diag(Sigma) <- diag(Sigma) + max(var_base * 1e-4, 1e-6)
return(Sigma)
}
# Get beta vectors for each method (all factors, not just main_factor)
beta_lasso_all_list <- lapply(valid_stocks, function(s) {
results[[s]]$lasso_loadings
})
beta_scad_all_list <- lapply(valid_stocks, function(s) {
results[[s]]$scad_loadings
})
beta_scad_improved_all_list <- lapply(valid_stocks, function(s) {
results[[s]]$scad_improved_loadings
})
# Compute Mean-Variance portfolio for each method
# LASSO
tryCatch({
# Use first stock's beta structure (all should have same factor structure)
beta_lasso_all <- if (length(beta_lasso_all_list) > 0) beta_lasso_all_list[[1]] else numeric()
Sigma_lasso <- build_covariance_mv(predicted_returns_lasso, beta_lasso_all,
X_factors_list, var_returns, rho_idio = 0.3)
mu_lasso <- predicted_returns_lasso  # Use predicted returns as expected return signals
Sigma_inv_lasso <- solve(Sigma_lasso)
w_lasso_raw <- as.vector(Sigma_inv_lasso %*% mu_lasso)
w_sum_lasso <- sum(w_lasso_raw)
if (abs(w_sum_lasso) > 1e-8 && is.finite(w_sum_lasso)) {
w_lasso_mv <- as.numeric(w_lasso_raw / w_sum_lasso)
# Clip extreme weights for stability
w_lasso_mv <- pmax(pmin(w_lasso_mv, 1), -1)
w_lasso_mv <- w_lasso_mv / sum(abs(w_lasso_mv))  # Renormalize
port_ret_lasso_mv <- sum(w_lasso_mv * next_returns)
}
}, error = function(e) {
# Fallback to beta-weighted
port_ret_lasso_mv <<- port_ret_lasso_beta
})
# SCAD
tryCatch({
beta_scad_all <- if (length(beta_scad_all_list) > 0) beta_scad_all_list[[1]] else numeric()
Sigma_scad <- build_covariance_mv(predicted_returns_scad, beta_scad_all,
X_factors_list, var_returns, rho_idio = 0.3)
mu_scad <- predicted_returns_scad
Sigma_inv_scad <- solve(Sigma_scad)
w_scad_raw <- as.vector(Sigma_inv_scad %*% mu_scad)
w_sum_scad <- sum(w_scad_raw)
if (abs(w_sum_scad) > 1e-8 && is.finite(w_sum_scad)) {
w_scad_mv <- as.numeric(w_scad_raw / w_sum_scad)
w_scad_mv <- pmax(pmin(w_scad_mv, 1), -1)
w_scad_mv <- w_scad_mv / sum(abs(w_scad_mv))
port_ret_scad_mv <- sum(w_scad_mv * next_returns)
}
}, error = function(e) {
port_ret_scad_mv <<- port_ret_scad_beta
})
# SCAD Improved
tryCatch({
beta_scad_improved_all <- if (length(beta_scad_improved_all_list) > 0) beta_scad_improved_all_list[[1]] else numeric()
Sigma_scad_improved <- build_covariance_mv(predicted_returns_scad_improved, beta_scad_improved_all,
X_factors_list, var_returns, rho_idio = 0.3)
mu_scad_improved <- predicted_returns_scad_improved
Sigma_inv_scad_improved <- solve(Sigma_scad_improved)
w_scad_improved_raw <- as.vector(Sigma_inv_scad_improved %*% mu_scad_improved)
w_sum_scad_improved <- sum(w_scad_improved_raw)
if (abs(w_sum_scad_improved) > 1e-8 && is.finite(w_sum_scad_improved)) {
w_scad_improved_mv <- as.numeric(w_scad_improved_raw / w_sum_scad_improved)
w_scad_improved_mv <- pmax(pmin(w_scad_improved_mv, 1), -1)
w_scad_improved_mv <- w_scad_improved_mv / sum(abs(w_scad_improved_mv))
port_ret_scad_improved_mv <- sum(w_scad_improved_mv * next_returns)
}
}, error = function(e) {
port_ret_scad_improved_mv <<- port_ret_scad_improved_beta
})
}
# ⭐ Debug: Check predicted returns (not single factor betas)
if (length(all_test_dates) <= 5 || test_date_str == all_test_dates[1]) {
cat(sprintf("\nDebug: Date %s\n", test_date_str))
cat(sprintf("  Predicted returns - Lasso: min=%.6f, max=%.6f, mean=%.6f\n",
min(predicted_returns_lasso), max(predicted_returns_lasso), mean(predicted_returns_lasso)))
cat(sprintf("  Predicted returns - SCAD: min=%.6f, max=%.6f, mean=%.6f\n",
min(predicted_returns_scad), max(predicted_returns_scad), mean(predicted_returns_scad)))
cat(sprintf("  Predicted returns - SCAD Improved: min=%.6f, max=%.6f, mean=%.6f\n",
min(predicted_returns_scad_improved), max(predicted_returns_scad_improved),
mean(predicted_returns_scad_improved)))
}
# Store beta-weighted returns
# ⭐ Remove threshold filtering - store all finite returns
if (is.finite(port_ret_lasso_beta)) {
portfolio_returns_beta$lasso <- c(portfolio_returns_beta$lasso, port_ret_lasso_beta)
}
if (is.finite(port_ret_scad_beta)) {
portfolio_returns_beta$scad <- c(portfolio_returns_beta$scad, port_ret_scad_beta)
}
if (is.finite(port_ret_scad_improved_beta)) {
portfolio_returns_beta$scad_improved <- c(portfolio_returns_beta$scad_improved, port_ret_scad_improved_beta)
}
# ⭐ Debug: Print portfolio returns for first few dates
if (length(all_test_dates) <= 5 || test_date_str == all_test_dates[1]) {
cat(sprintf("  Portfolio Returns (Beta-weighted) - Lasso: %.6f, SCAD: %.6f, SCAD_Improved: %.6f\n",
port_ret_lasso_beta, port_ret_scad_beta, port_ret_scad_improved_beta))
cat(sprintf("  Predicted Returns Sum (abs) - Lasso: %.6f, SCAD: %.6f, SCAD_Improved: %.6f\n",
sum(abs(predicted_returns_lasso)), sum(abs(predicted_returns_scad)),
sum(abs(predicted_returns_scad_improved))))
}
# Store mean-variance returns
# ⭐ Store all finite returns (remove threshold to see all results)
if (is.finite(port_ret_lasso_mv)) {
portfolio_returns_mv$lasso <- c(portfolio_returns_mv$lasso, port_ret_lasso_mv)
}
if (is.finite(port_ret_scad_mv)) {
portfolio_returns_mv$scad <- c(portfolio_returns_mv$scad, port_ret_scad_mv)
}
if (is.finite(port_ret_scad_improved_mv)) {
portfolio_returns_mv$scad_improved <- c(portfolio_returns_mv$scad_improved, port_ret_scad_improved_mv)
}
# ⭐ Debug: Print first few dates to see what's happening
if (length(all_test_dates) <= 5 || test_date_str == all_test_dates[1]) {
cat(sprintf("  MV Returns - Lasso: %.6f, SCAD: %.6f, SCAD_Improved: %.6f\n",
port_ret_lasso_mv, port_ret_scad_mv, port_ret_scad_improved_mv))
cat(sprintf("  MV Weights Sum - Lasso: %.6f, SCAD: %.6f, SCAD_Improved: %.6f\n",
ifelse(exists("w_sum_lasso"), w_sum_lasso, NA),
ifelse(exists("w_sum_scad"), w_sum_scad, NA),
ifelse(exists("w_sum_scad_improved"), w_sum_scad_improved, NA)))
}
}
}
# Calculate performance for both methods
perf_table_beta <- data.frame(Method = character(), Return = numeric(), Volatility = numeric(),
Sharpe = numeric(), IR = numeric(), stringsAsFactors = FALSE)
perf_table_mv <- data.frame(Method = character(), Return = numeric(), Volatility = numeric(),
Sharpe = numeric(), IR = numeric(), stringsAsFactors = FALSE)
for (method in c("lasso", "scad", "scad_improved")) {
method_name <- ifelse(method == "scad", "SCAD (LLA)",
ifelse(method == "scad_improved", "SCAD (LLA_Updated)", "LASSO"))
# Beta-weighted portfolio performance
returns_beta <- portfolio_returns_beta[[method]]
# ⭐ Remove threshold filtering - keep all finite returns
returns_beta <- returns_beta[is.finite(returns_beta)]
# ⭐ Debug: Print how many returns we have
if (length(returns_beta) > 0) {
cat(sprintf("  %s Beta: %d valid returns (range: %.4f to %.4f)\n",
method_name, length(returns_beta), min(returns_beta), max(returns_beta)))
}
if (length(returns_beta) > 5) {  # Reduced from 30 to 5
ann_return_beta <- mean(returns_beta) * 252
ann_vol_beta <- sd(returns_beta) * sqrt(252)
sharpe_beta <- ifelse(ann_vol_beta > 0, ann_return_beta / ann_vol_beta, 0)
ir_beta <- sharpe_beta
perf_table_beta <- rbind(perf_table_beta, data.frame(
Method = method_name, Return = ann_return_beta, Volatility = ann_vol_beta,
Sharpe = sharpe_beta, IR = ir_beta, stringsAsFactors = FALSE))
}
# Mean-variance portfolio performance
returns_mv <- portfolio_returns_mv[[method]]
# ⭐ Keep all finite returns (no threshold filtering)
returns_mv <- returns_mv[is.finite(returns_mv)]
# ⭐ Debug: Print how many returns we have
if (length(returns_mv) > 0) {
cat(sprintf("  %s MV: %d valid returns (range: %.4f to %.4f)\n",
method_name, length(returns_mv), min(returns_mv), max(returns_mv)))
}
if (length(returns_mv) > 5) {  # Reduced minimum requirement to 5
ann_return_mv <- mean(returns_mv) * 252
ann_vol_mv <- sd(returns_mv) * sqrt(252)
sharpe_mv <- ifelse(ann_vol_mv > 0, ann_return_mv / ann_vol_mv, 0)
ir_mv <- sharpe_mv
perf_table_mv <- rbind(perf_table_mv, data.frame(
Method = method_name, Return = ann_return_mv, Volatility = ann_vol_mv,
Sharpe = sharpe_mv, IR = ir_mv, stringsAsFactors = FALSE))
}
}
# Print Beta-weighted portfolio performance
cat("Portfolio Performance (Beta-Weighted):\n")
cat(paste(rep("=", 70), collapse = ""), "\n")
for (i in 1:nrow(perf_table_beta)) {
cat(sprintf("%s Portfolio (Beta-Weighted):\n", perf_table_beta$Method[i]))
cat(sprintf("  Annualized Return: %.2f%%\n", perf_table_beta$Return[i] * 100))
cat(sprintf("  Annualized Volatility: %.2f%%\n", perf_table_beta$Volatility[i] * 100))
cat(sprintf("  Sharpe Ratio: %.4f\n", perf_table_beta$Sharpe[i]))
cat(sprintf("  Information Ratio: %.4f\n", perf_table_beta$IR[i]))
cat("\n")
}
# Print Mean-variance portfolio performance
cat("Portfolio Performance (Mean-Variance):\n")
cat(paste(rep("=", 70), collapse = ""), "\n")
for (i in 1:nrow(perf_table_mv)) {
cat(sprintf("%s Portfolio (Mean-Variance):\n", perf_table_mv$Method[i]))
cat(sprintf("  Annualized Return: %.2f%%\n", perf_table_mv$Return[i] * 100))
cat(sprintf("  Annualized Volatility: %.2f%%\n", perf_table_mv$Volatility[i] * 100))
cat(sprintf("  Sharpe Ratio: %.4f\n", perf_table_mv$Sharpe[i]))
cat(sprintf("  Information Ratio: %.4f\n", perf_table_mv$IR[i]))
cat("\n")
}
# Summary tables for both methods
if (nrow(perf_table_beta) >= 2) {
cat("\nSummary Table (Beta-Weighted):\n")
cat(sprintf("%-15s %12s %12s %12s %12s\n", "Method", "Return (%)", "Vol (%)", "Sharpe", "IR"))
cat(paste(rep("-", 65), collapse = ""), "\n")
for (i in 1:nrow(perf_table_beta)) {
cat(sprintf("%-15s %12.2f %12.2f %12.4f %12.4f\n",
perf_table_beta$Method[i], perf_table_beta$Return[i] * 100,
perf_table_beta$Volatility[i] * 100, perf_table_beta$Sharpe[i], perf_table_beta$IR[i]))
}
cat("\n")
}
if (nrow(perf_table_mv) >= 2) {
cat("\nSummary Table (Mean-Variance):\n")
cat(sprintf("%-15s %12s %12s %12s %12s\n", "Method", "Return (%)", "Vol (%)", "Sharpe", "IR"))
cat(paste(rep("-", 65), collapse = ""), "\n")
for (i in 1:nrow(perf_table_mv)) {
cat(sprintf("%-15s %12.2f %12.2f %12.4f %12.4f\n",
perf_table_mv$Method[i], perf_table_mv$Return[i] * 100,
perf_table_mv$Volatility[i] * 100, perf_table_mv$Sharpe[i], perf_table_mv$IR[i]))
}
cat("\n")
}
# Best performance comparison
if (nrow(perf_table_beta) >= 2 && nrow(perf_table_mv) >= 2) {
best_return_beta_idx <- which.max(perf_table_beta$Return)
best_sharpe_beta_idx <- which.max(perf_table_beta$Sharpe)
best_return_mv_idx <- which.max(perf_table_mv$Return)
best_sharpe_mv_idx <- which.max(perf_table_mv$Sharpe)
cat("\nBest Performance (Beta-Weighted):\n")
cat(sprintf("  Highest Return: %s (%.2f%%)\n",
perf_table_beta$Method[best_return_beta_idx], perf_table_beta$Return[best_return_beta_idx] * 100))
cat(sprintf("  Highest Sharpe: %s (%.4f)\n",
perf_table_beta$Method[best_sharpe_beta_idx], perf_table_beta$Sharpe[best_sharpe_beta_idx]))
cat("\nBest Performance (Mean-Variance):\n")
cat(sprintf("  Highest Return: %s (%.2f%%)\n",
perf_table_mv$Method[best_return_mv_idx], perf_table_mv$Return[best_return_mv_idx] * 100))
cat(sprintf("  Highest Sharpe: %s (%.4f)\n",
perf_table_mv$Method[best_sharpe_mv_idx], perf_table_mv$Sharpe[best_sharpe_mv_idx]))
}
return(list(beta_weighted = perf_table_beta, mean_variance = perf_table_mv))
}
main <- function() {
cat("===========================================\n")
cat("Financial Scenario: SCAD vs LASSO\n")
cat("Highly Correlated Factor Features\n")
cat("===========================================\n\n")
flush.console()
ff_factors <- download_factors(start_date = "2020-01-01")
stock_data <- download_stocks(start_date = "2020-01-01")
data_list <- prepare_data(stock_data, ff_factors)
if (length(data_list) == 0) stop("No valid stock data available")
results <- estimate_loadings(data_list, train_ratio = 0.7)
if (length(results) == 0) stop("Failed to estimate factor loadings")
pred_summary <- evaluate_predictions(data_list, results, ff_factors)
portfolio_perf <- construct_portfolio(data_list, results, ff_factors)
cat("\n===========================================\n")
cat("FINAL SUMMARY\n")
cat("===========================================\n")
cat("\n1. Predictive Power (MSE, OOS R²):\n")
print(pred_summary)
cat("\n2. Portfolio Performance (Return, Sharpe):\n")
print(portfolio_perf)
cat("\n✅ Analysis completed!\n\n")
return(list(factors = ff_factors, results = results,
predictions = pred_summary, portfolio = portfolio_perf))
}
cat("Starting analysis...\n")
flush.console()
tryCatch({
results <- main()
}, error = function(e) {
cat("\n===========================================\n")
cat("❌ Error occurred during analysis\n")
cat("===========================================\n")
cat(sprintf("Error message: %s\n\n", e$message))
cat("Possible solutions:\n")
cat("1. Set USE_SIMULATED_DATA = TRUE at the top of the file to use simulated data\n")
cat("2. Check your internet connection\n")
cat("3. Wait 5-10 minutes and try again (Yahoo Finance rate limiting)\n")
cat("4. Try using a VPN or different network\n")
cat("5. Reduce the number of stocks in download_stocks() function\n\n")
cat("To use simulated data (recommended), edit real_data.R line 23 and set:\n")
cat("   USE_SIMULATED_DATA <- TRUE\n\n")
print(traceback())
stop(e)
})
# 运行 real data（需要 2-5 分钟，需要下载数据）
source("real_data.R")
# 运行 real data（需要 2-5 分钟，需要下载数据）
source("real_data.R")
# 运行 real data（需要 2-5 分钟，需要下载数据）
source("real_data.R")
# 运行 real data（需要 2-5 分钟，需要下载数据）
source("real_data.R")
# 运行 real data（需要 2-5 分钟，需要下载数据）
source("real_data.R")
# 运行 real data（需要 2-5 分钟，需要下载数据）
source("real_data.R")
# 运行 real data（需要 2-5 分钟，需要下载数据）
source("real_data.R")
# 运行 real data（需要 2-5 分钟，需要下载数据）
source("real_data.R")
# 运行 real data（需要 2-5 分钟，需要下载数据）
source("real_data.R")
# 运行 real data（需要 2-5 分钟，需要下载数据）
source("real_data.R")
